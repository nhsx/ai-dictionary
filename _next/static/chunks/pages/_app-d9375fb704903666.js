(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[888],{1780:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/_app",function(){return n(8510)}])},7826:function(e,t,n){"use strict";n.d(t,{O:function(){return o}});var o="/ai-dictionary"},8510:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return c}});var o=n(5893),r=n(9008),a=n(2804),i=n(7826);n(4186);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function u(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{},o=Object.keys(n);"function"===typeof Object.getOwnPropertySymbols&&(o=o.concat(Object.getOwnPropertySymbols(n).filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable})))),o.forEach((function(t){s(e,t,n[t])}))}return e}function c(e){var t=e.Component,n=e.pageProps;return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(r.default,{children:[(0,o.jsx)("title",{children:"AI Dictionary | NHS AI Lab"}),(0,o.jsx)("link",{rel:"icon",href:"".concat(i.O,"/favicon.ico")}),(0,o.jsx)("link",{href:"https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400;500;600;700&display=swap",rel:"stylesheet"})]}),(0,o.jsx)(a.Wh,{children:(0,o.jsx)("div",{className:"antialiased",children:(0,o.jsx)(t,u({},n))})})]})}},4186:function(){},9008:function(e,t,n){e.exports=n(5443)},2804:function(e,t,n){"use strict";n.d(t,{Wh:function(){return Yi},cn:function(){return Ji},FV:function(){return Qi},sJ:function(){return Xi}});var o=n(7294),r=n(3935);var a=function(e){const t=new Error(e);if(void 0===t.stack)try{throw t}catch(n){}return t};var i=function(e){return!!e&&"function"===typeof e.then};var s=function(e,t){if(null!=e)return e;throw a(null!==t&&void 0!==t?t:"Got unexpected null or undefined")};function u(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}class c{getValue(){throw a("BaseLoadable")}toPromise(){throw a("BaseLoadable")}valueMaybe(){throw a("BaseLoadable")}valueOrThrow(){throw a(`Loadable expected value, but in "${this.state}" state`)}promiseMaybe(){throw a("BaseLoadable")}promiseOrThrow(){throw a(`Loadable expected promise, but in "${this.state}" state`)}errorMaybe(){throw a("BaseLoadable")}errorOrThrow(){throw a(`Loadable expected error, but in "${this.state}" state`)}is(e){return e.state===this.state&&e.contents===this.contents}map(e){throw a("BaseLoadable")}}class l extends c{constructor(e){super(),u(this,"state","hasValue"),u(this,"contents",void 0),this.contents=e}getValue(){return this.contents}toPromise(){return Promise.resolve(this.contents)}valueMaybe(){return this.contents}valueOrThrow(){return this.contents}promiseMaybe(){}errorMaybe(){}map(e){try{const t=e(this.contents);return i(t)?v(t):m(t)?t:h(t)}catch(t){return i(t)?v(t.next((()=>this.map(e)))):p(t)}}}class d extends c{constructor(e){super(),u(this,"state","hasError"),u(this,"contents",void 0),this.contents=e}getValue(){throw this.contents}toPromise(){return Promise.reject(this.contents)}valueMaybe(){}promiseMaybe(){}errorMaybe(){return this.contents}errorOrThrow(){return this.contents}map(e){return this}}class f extends c{constructor(e){super(),u(this,"state","loading"),u(this,"contents",void 0),this.contents=e}getValue(){throw this.contents}toPromise(){return this.contents}valueMaybe(){}promiseMaybe(){return this.contents}promiseOrThrow(){return this.contents}errorMaybe(){}map(e){return v(this.contents.then((t=>{const n=e(t);if(m(n)){const e=n;switch(e.state){case"hasValue":return e.contents;case"hasError":throw e.contents;case"loading":return e.contents}}return n})).catch((t=>{if(i(t))return t.then((()=>this.map(e).contents));throw t})))}}function h(e){return Object.freeze(new l(e))}function p(e){return Object.freeze(new d(e))}function v(e){return Object.freeze(new f(e))}function y(e){const t=function(e){return e.every((e=>"hasValue"===e.state))?h(e.map((e=>e.contents))):e.some((e=>"hasError"===e.state))?p(s(e.find((e=>"hasError"===e.state)),"Invalid loadable passed to loadableAll").contents):v(Promise.all(e.map((e=>e.contents))))}((Array.isArray(e)?e:Object.getOwnPropertyNames(e).map((t=>e[t]))).map((e=>m(e)?e:i(e)?v(e):h(e))));return Array.isArray(e)?t:t.map((t=>Object.getOwnPropertyNames(e).reduce(((e,n,o)=>({...e,[n]:t[o]})),{})))}function m(e){return e instanceof c}const _={of:e=>i(e)?v(e):m(e)?e:h(e),error:e=>p(e),all:y,isLoadable:m};var g={loadableWithValue:h,loadableWithError:p,loadableWithPromise:v,loadableLoading:function(){return Object.freeze(new f(new Promise((()=>{}))))},loadableAll:y,isLoadable:m,RecoilLoadable:_},S=g.loadableWithValue,b=g.loadableWithError,T=g.loadableWithPromise,w=g.loadableLoading,R=g.loadableAll,A=g.isLoadable,E=g.RecoilLoadable,N=Object.freeze({__proto__:null,loadableWithValue:S,loadableWithError:b,loadableWithPromise:T,loadableLoading:w,loadableAll:R,isLoadable:A,RecoilLoadable:E});class k{constructor(e){u(this,"key",void 0),this.key=e}}class V extends k{}class L extends k{}var M={AbstractRecoilValue:k,RecoilState:V,RecoilValueReadOnly:L,isRecoilValue:function(e){return e instanceof V||e instanceof L}},C=M.AbstractRecoilValue,U=M.RecoilState,B=M.RecoilValueReadOnly,D=M.isRecoilValue,O=Object.freeze({__proto__:null,AbstractRecoilValue:C,RecoilState:U,RecoilValueReadOnly:B,isRecoilValue:D});var I=function(e,...t){0};const x=(new Map).set("recoil_hamt_2020",!0).set("recoil_sync_external_store",!0).set("recoil_suppress_rerender_in_callback",!0).set("recoil_memory_managament_2020",!0);function P(e){var t;return null!==(t=x.get(e))&&void 0!==t&&t}P.setPass=e=>{x.set(e,!0)},P.setFail=e=>{x.set(e,!1)},P.clear=()=>{x.clear()};var z=P;var F=function(e,t){return function*(){let n=0;for(const o of e)yield t(o,n++)}()};var j=function(e,t,{error:n}={}){return null};class W{}const $=new W;class G extends Error{constructor(e){super(`Tried to set the value of Recoil selector ${e} using an updater function, but it is an async selector in a pending or error state; this is not supported.`)}}const H=new Map,q=new Map;class K extends Error{}const Z=new Map;function Y(e){return Z.get(e)}var J={nodes:H,recoilValues:q,registerNode:function(e){if(H.has(e.key)){const t=`Duplicate atom key "${e.key}". This is a FATAL ERROR in\n      production. But it is safe to ignore this warning if it occurred because of\n      hot module replacement.`;console.warn(t)}H.set(e.key,e);const t=null==e.set?new O.RecoilValueReadOnly(e.key):new O.RecoilState(e.key);return q.set(e.key,t),t},getNode:function(e){const t=H.get(e);if(null==t)throw new K(`Missing definition for RecoilValue: "${e}""`);return t},getNodeMaybe:function(e){return H.get(e)},deleteNodeConfigIfPossible:function(e){var t;if(!z("recoil_memory_managament_2020"))return;const n=H.get(e);var o;null!==n&&void 0!==n&&null!==(t=n.shouldDeleteConfigOnRelease)&&void 0!==t&&t.call(n)&&(H.delete(e),null===(o=Y(e))||void 0===o||o(),Z.delete(e))},setConfigDeletionHandler:function(e,t){z("recoil_memory_managament_2020")&&(void 0===t?Z.delete(e):Z.set(e,t))},getConfigDeletionHandler:Y,recoilValuesForKeys:function(e){return F(e,(e=>s(q.get(e))))},NodeMissingError:K,DefaultValue:W,DEFAULT_VALUE:$,RecoilValueNotReady:G};var X={enqueueExecution:function(e,t){t()}};var Q,ee=(function(e){var t="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"===typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},n={},o=Math.pow(2,5),r=o-1,a=o/2,i=o/4,s={},u=function(e){return function(){return e}},c=n.hash=function(e){var n="undefined"===typeof e?"undefined":t(e);if("number"===n)return e;"string"!==n&&(e+="");for(var o=0,r=0,a=e.length;r<a;++r)o=(o<<5)-o+e.charCodeAt(r)|0;return o},l=function(e,t){return t>>>e&r},d=function(e){return 1<<e},f=function(e,t){return n=e&t-1,n=(n=(858993459&(n-=n>>1&1431655765))+(n>>2&858993459))+(n>>4)&252645135,127&(n+=n>>8)+(n>>16);var n},h=function(e,t,n,o){var r=o;if(!e){var a=o.length;r=new Array(a);for(var i=0;i<a;++i)r[i]=o[i]}return r[t]=n,r},p=function(e,t,n){var o=n.length-1,r=0,a=0,i=n;if(e)r=a=t;else for(i=new Array(o);r<t;)i[a++]=n[r++];for(++r;r<=o;)i[a++]=n[r++];return e&&(i.length=o),i},v={__hamt_isEmpty:!0},y=function(e){return e===v||e&&e.__hamt_isEmpty},m=function(e,t,n,o){return{type:1,edit:e,hash:t,key:n,value:o,_modify:w}},_=function(e,t,n){return{type:2,edit:e,hash:t,children:n,_modify:R}},g=function(e,t,n){return{type:3,edit:e,mask:t,children:n,_modify:A}},S=function(e,t,n){return{type:4,edit:e,size:t,children:n,_modify:E}},b=function e(t,n,o,r,a,i){if(o===a)return _(t,o,[i,r]);var s=l(n,o),u=l(n,a);return g(t,d(s)|d(u),s===u?[e(t,n+5,o,r,a,i)]:s<u?[r,i]:[i,r])},T=function(e,t){return e===t.edit},w=function(e,t,n,o,r,a,i){if(t(a,this.key)){var u=o(this.value);return u===this.value?this:u===s?(--i.value,v):T(e,this)?(this.value=u,this):m(e,r,a,u)}var c=o();return c===s?this:(++i.value,b(e,n,this.hash,this,r,m(e,r,a,c)))},R=function(e,t,n,o,r,a,i){if(r===this.hash){var u=function(e,t,n,o,r,a,i,u){for(var c=r.length,l=0;l<c;++l){var d=r[l];if(n(i,d.key)){var f=d.value,v=a(f);return v===f?r:v===s?(--u.value,p(e,l,r)):h(e,l,m(t,o,i,v),r)}}var y=a();return y===s?r:(++u.value,h(e,c,m(t,o,i,y),r))}(T(e,this),e,t,this.hash,this.children,o,a,i);return u===this.children?this:u.length>1?_(e,this.hash,u):u[0]}var c=o();return c===s?this:(++i.value,b(e,n,this.hash,this,r,m(e,r,a,c)))},A=function(e,t,n,o,r,i,s){var u=this.mask,c=this.children,m=l(n,r),_=d(m),b=f(u,_),w=u&_,R=w?c[b]:v,A=R._modify(e,t,n+5,o,r,i,s);if(R===A)return this;var E,N=T(e,this),k=u,V=void 0;if(w&&y(A)){if(!(k&=~_))return v;if(c.length<=2&&((E=c[1^b])===v||1===E.type||2===E.type))return c[1^b];V=p(N,b,c)}else if(w||y(A))V=h(N,b,A,c);else{if(c.length>=a)return function(e,t,n,o,r){for(var a=[],i=o,s=0,u=0;i;++u)1&i&&(a[u]=r[s++]),i>>>=1;return a[t]=n,S(e,s+1,a)}(e,m,A,u,c);k|=_,V=function(e,t,n,o){var r=o.length;if(e){for(var a=r;a>=t;)o[a--]=o[a];return o[t]=n,o}for(var i=0,s=0,u=new Array(r+1);i<t;)u[s++]=o[i++];for(u[t]=n;i<r;)u[++s]=o[i++];return u}(N,b,A,c)}return N?(this.mask=k,this.children=V,this):g(e,k,V)},E=function(e,t,n,o,r,a,s){var u=this.size,c=this.children,d=l(n,r),f=c[d],p=(f||v)._modify(e,t,n+5,o,r,a,s);if(f===p)return this;var m=T(e,this),_=void 0;if(y(f)&&!y(p))++u,_=h(m,d,p,c);else if(!y(f)&&y(p)){if(--u<=i)return function(e,t,n,o){for(var r=new Array(t-1),a=0,i=0,s=0,u=o.length;s<u;++s)if(s!==n){var c=o[s];c&&!y(c)&&(r[a++]=c,i|=1<<s)}return g(e,i,r)}(e,u,d,c);_=h(m,d,v,c)}else _=h(m,d,p,c);return m?(this.size=u,this.children=_,this):S(e,u,_)};function N(e,t,n,o,r){this._editable=e,this._edit=t,this._config=n,this._root=o,this._size=r}v._modify=function(e,t,n,o,r,a,i){var u=o();return u===s?v:(++i.value,m(e,r,a,u))},N.prototype.setTree=function(e,t){return this._editable?(this._root=e,this._size=t,this):e===this._root?this:new N(this._editable,this._edit,this._config,e,t)};var k=n.tryGetHash=function(e,t,n,o){for(var r=o._root,a=0,i=o._config.keyEq;;)switch(r.type){case 1:return i(n,r.key)?r.value:e;case 2:if(t===r.hash)for(var s=r.children,u=0,c=s.length;u<c;++u){var h=s[u];if(i(n,h.key))return h.value}return e;case 3:var p=l(a,t),v=d(p);if(r.mask&v){r=r.children[f(r.mask,v)],a+=5;break}return e;case 4:if(r=r.children[l(a,t)]){a+=5;break}return e;default:return e}};N.prototype.tryGetHash=function(e,t,n){return k(e,t,n,this)};var V=n.tryGet=function(e,t,n){return k(e,n._config.hash(t),t,n)};N.prototype.tryGet=function(e,t){return V(e,t,this)};var L=n.getHash=function(e,t,n){return k(void 0,e,t,n)};N.prototype.getHash=function(e,t){return L(e,t,this)},n.get=function(e,t){return k(void 0,t._config.hash(e),e,t)},N.prototype.get=function(e,t){return V(t,e,this)};var M=n.has=function(e,t,n){return k(s,e,t,n)!==s};N.prototype.hasHash=function(e,t){return M(e,t,this)};var C=n.has=function(e,t){return M(t._config.hash(e),e,t)};N.prototype.has=function(e){return C(e,this)};var U=function(e,t){return e===t};n.make=function(e){return new N(0,0,{keyEq:e&&e.keyEq||U,hash:e&&e.hash||c},v,0)},n.empty=n.make();var B=n.isEmpty=function(e){return e&&!!y(e._root)};N.prototype.isEmpty=function(){return B(this)};var D=n.modifyHash=function(e,t,n,o){var r={value:o._size},a=o._root._modify(o._editable?o._edit:NaN,o._config.keyEq,0,e,t,n,r);return o.setTree(a,r.value)};N.prototype.modifyHash=function(e,t,n){return D(n,e,t,this)};var O=n.modify=function(e,t,n){return D(e,n._config.hash(t),t,n)};N.prototype.modify=function(e,t){return O(t,e,this)};var I=n.setHash=function(e,t,n,o){return D(u(n),e,t,o)};N.prototype.setHash=function(e,t,n){return I(e,t,n,this)};var x=n.set=function(e,t,n){return I(n._config.hash(e),e,t,n)};N.prototype.set=function(e,t){return x(e,t,this)};var P=u(s),z=n.removeHash=function(e,t,n){return D(P,e,t,n)};N.prototype.removeHash=N.prototype.deleteHash=function(e,t){return z(e,t,this)};var F=n.remove=function(e,t){return z(t._config.hash(e),e,t)};N.prototype.remove=N.prototype.delete=function(e){return F(e,this)};var j=n.beginMutation=function(e){return new N(e._editable+1,e._edit+1,e._config,e._root,e._size)};N.prototype.beginMutation=function(){return j(this)};var W=n.endMutation=function(e){return e._editable=e._editable&&e._editable-1,e};N.prototype.endMutation=function(){return W(this)};var $=n.mutate=function(e,t){var n=j(t);return e(n),W(n)};N.prototype.mutate=function(e){return $(e,this)};var G=function(e){return e&&H(e[0],e[1],e[2],e[3],e[4])},H=function(e,t,n,o,r){for(;n<e;){var a=t[n++];if(a&&!y(a))return q(a,o,[e,t,n,o,r])}return G(r)},q=function(e,t,n){switch(e.type){case 1:return{value:t(e),rest:n};case 2:case 4:case 3:var o=e.children;return H(o.length,o,0,t,n);default:return G(n)}},K={done:!0};function Z(e){this.v=e}Z.prototype.next=function(){if(!this.v)return K;var e=this.v;return this.v=G(e.rest),e},Z.prototype[Symbol.iterator]=function(){return this};var Y=function(e,t){return new Z(q(e._root,t))},J=function(e){return[e.key,e.value]},X=n.entries=function(e){return Y(e,J)};N.prototype.entries=N.prototype[Symbol.iterator]=function(){return X(this)};var Q=function(e){return e.key},ee=n.keys=function(e){return Y(e,Q)};N.prototype.keys=function(){return ee(this)};var te=function(e){return e.value},ne=n.values=N.prototype.values=function(e){return Y(e,te)};N.prototype.values=function(){return ne(this)};var oe=n.fold=function(e,t,n){var o=n._root;if(1===o.type)return e(t,o.value,o.key);for(var r=[o.children],a=void 0;a=r.pop();)for(var i=0,s=a.length;i<s;){var u=a[i++];u&&u.type&&(1===u.type?t=e(t,u.value,u.key):r.push(u.children))}return t};N.prototype.fold=function(e,t){return oe(e,t,this)};var re=n.forEach=function(e,t){return oe((function(n,o,r){return e(o,r,t)}),null,t)};N.prototype.forEach=function(e){return re(e,this)};var ae=n.count=function(e){return e._size};N.prototype.count=function(){return ae(this)},Object.defineProperty(N.prototype,"size",{get:N.prototype.count}),e.exports?e.exports=n:(void 0).hamt=n}(Q={exports:{}},Q.exports),Q.exports);class te{constructor(e){u(this,"_map",void 0),this._map=new Map(null===e||void 0===e?void 0:e.entries())}keys(){return this._map.keys()}entries(){return this._map.entries()}get(e){return this._map.get(e)}has(e){return this._map.has(e)}set(e,t){return this._map.set(e,t),this}delete(e){return this._map.delete(e),this}clone(){return oe(this)}toMap(){return new Map(this._map)}}class ne{constructor(e){if(u(this,"_hamt",ee.empty.beginMutation()),e instanceof ne){const t=e._hamt.endMutation();e._hamt=t.beginMutation(),this._hamt=t.beginMutation()}else if(e)for(const[t,n]of e.entries())this._hamt.set(t,n)}keys(){return this._hamt.keys()}entries(){return this._hamt.entries()}get(e){return this._hamt.get(e)}has(e){return this._hamt.has(e)}set(e,t){return this._hamt.set(e,t),this}delete(e){return this._hamt.delete(e),this}clone(){return oe(this)}toMap(){return new Map(this._hamt)}}function oe(e){return z("recoil_hamt_2020")?new ne(e):new te(e)}var re=oe,ae=Object.freeze({__proto__:null,persistentMap:re});var ie=function(e,...t){const n=new Set;e:for(const o of e){for(const e of t)if(e.has(o))continue e;n.add(o)}return n};var se=function(e,t){const n=new Map;return e.forEach(((e,o)=>{n.set(o,t(e,o))})),n};function ue(e,t,n){const{nodeDeps:o,nodeToNodeSubscriptions:r}=t;e.forEach(((e,t)=>{const a=o.get(t);if(a&&n&&a!==n.nodeDeps.get(t))return;o.set(t,new Set(e));if((null==a?e:ie(e,a)).forEach((e=>{r.has(e)||r.set(e,new Set);s(r.get(e)).add(t)})),a){ie(a,e).forEach((e=>{if(!r.has(e))return;const n=s(r.get(e));n.delete(t),0===n.size&&r.delete(e)}))}}))}var ce={addToDependencyMap:function(e,t,n){n.has(e)||n.set(e,new Set),s(n.get(e)).add(t)},cloneGraph:function(e){return{nodeDeps:se(e.nodeDeps,(e=>new Set(e))),nodeToNodeSubscriptions:se(e.nodeToNodeSubscriptions,(e=>new Set(e)))}},graph:function(){return{nodeDeps:new Map,nodeToNodeSubscriptions:new Map}},mergeDepsIntoDependencyMap:function(e,t){e.forEach(((e,n)=>{t.has(n)||t.set(n,new Set);const o=s(t.get(n));e.forEach((e=>o.add(e)))}))},saveDependencyMapToStore:function(e,t,n){var o,r,a,i;const s=t.getState();n!==s.currentTree.version&&n!==(null===(o=s.nextTree)||void 0===o?void 0:o.version)&&n!==(null===(r=s.previousTree)||void 0===r?void 0:r.version)&&j("Tried to save dependencies to a discarded tree");const u=t.getGraph(n);if(ue(e,u),n===(null===(a=s.previousTree)||void 0===a?void 0:a.version)){ue(e,t.getGraph(s.currentTree.version),u)}if(n===(null===(i=s.previousTree)||void 0===i?void 0:i.version)||n===s.currentTree.version){var c;const n=null===(c=s.nextTree)||void 0===c?void 0:c.version;if(void 0!==n){ue(e,t.getGraph(n),u)}}}};let le=0;let de=0;let fe=0;var he={getNextTreeStateVersion:()=>le++,getNextStoreID:()=>de++,getNextComponentID:()=>fe++};const{persistentMap:pe}=ae,{graph:ve}=ce,{getNextTreeStateVersion:ye}=he;function me(){const e=ye();return{version:e,stateID:e,transactionMetadata:{},dirtyAtoms:new Set,atomValues:pe(),nonvalidatedAtoms:pe()}}var _e={makeEmptyTreeState:me,makeEmptyStoreState:function(){const e=me();return{currentTree:e,nextTree:null,previousTree:null,commitDepth:0,knownAtoms:new Set,knownSelectors:new Set,transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:(new Map).set(e.version,ve()),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}},getNextTreeStateVersion:ye};class ge{}var Se={RetentionZone:ge,retentionZone:function(){return new ge}};var be={setByAddingToSet:function(e,t){const n=new Set(e);return n.add(t),n},setByDeletingFromSet:function(e,t){const n=new Set(e);return n.delete(t),n},mapBySettingInMap:function(e,t,n){const o=new Map(e);return o.set(t,n),o},mapByUpdatingInMap:function(e,t,n){const o=new Map(e);return o.set(t,n(o.get(t))),o},mapByDeletingFromMap:function(e,t){const n=new Map(e);return n.delete(t),n},mapByDeletingMultipleFromMap:function(e,t){const n=new Map(e);return t.forEach((e=>n.delete(e))),n}};var Te=function*(e,t){let n=0;for(const o of e)t(o,n++)&&(yield o)};var we=function(e,t){return new Proxy(e,{get:(e,n)=>(!(n in e)&&n in t&&(e[n]=t[n]()),e[n]),ownKeys:e=>Object.keys(e)})};const{getNode:Re,getNodeMaybe:Ae,recoilValuesForKeys:Ee}=J,{RetentionZone:Ne}=Se,{setByAddingToSet:ke}=be,Ve=Object.freeze(new Set);class Le extends Error{}function Me(e,t,n,o){const r=e.getState();if(r.nodeCleanupFunctions.has(n))return;const a=Re(n),i=function(e,t,n){if(!z("recoil_memory_managament_2020"))return()=>{};const{nodesRetainedByZone:o}=e.getState().retention;function r(e){let n=o.get(e);n||o.set(e,n=new Set),n.add(t)}if(n instanceof Ne)r(n);else if(Array.isArray(n))for(const a of n)r(a);return()=>{if(!z("recoil_memory_managament_2020"))return;const{retention:o}=e.getState();function r(e){const n=o.nodesRetainedByZone.get(e);null===n||void 0===n||n.delete(t),n&&0===n.size&&o.nodesRetainedByZone.delete(e)}if(n instanceof Ne)r(n);else if(Array.isArray(n))for(const e of n)r(e)}}(e,n,a.retainedBy),s=a.init(e,t,o);r.nodeCleanupFunctions.set(n,(()=>{s(),i()}))}function Ce(e,t,n){return Re(n).peek(e,t)}function Ue(e,t,n){const o=new Set,r=Array.from(n),a=e.getGraph(t.version);for(let s=r.pop();s;s=r.pop()){var i;o.add(s);const e=null!==(i=a.nodeToNodeSubscriptions.get(s))&&void 0!==i?i:Ve;for(const t of e)o.has(t)||r.push(t)}return o}var Be,De,Oe,Ie={getNodeLoadable:function(e,t,n){return Me(e,t,n,"get"),Re(n).get(e,t)},peekNodeLoadable:Ce,setNodeValue:function(e,t,n,o){const r=Re(n);if(null==r.set)throw new Le(`Attempt to set read-only RecoilValue: ${n}`);const a=r.set;return Me(e,t,n,"set"),a(e,t,o)},initializeNode:function(e,t,n){Me(e,e.getState().currentTree,t,n)},cleanUpNode:function(e,t){var n;const o=e.getState();null===(n=o.nodeCleanupFunctions.get(t))||void 0===n||n(),o.nodeCleanupFunctions.delete(t)},setUnvalidatedAtomValue_DEPRECATED:function(e,t,n){var o;const r=Ae(t);return null===r||void 0===r||null===(o=r.invalidate)||void 0===o||o.call(r,e),{...e,atomValues:e.atomValues.clone().delete(t),nonvalidatedAtoms:e.nonvalidatedAtoms.clone().set(t,n),dirtyAtoms:ke(e.dirtyAtoms,t)}},peekNodeInfo:function(e,t,n){const o=e.getState(),r=e.getGraph(t.version),a=Re(n).nodeType;return we({type:a},{loadable:()=>Ce(e,t,n),isActive:()=>o.knownAtoms.has(n)||o.knownSelectors.has(n),isSet:()=>"selector"!==a&&t.atomValues.has(n),isModified:()=>t.dirtyAtoms.has(n),deps:()=>{var e;return Ee(null!==(e=r.nodeDeps.get(n))&&void 0!==e?e:[])},subscribers:()=>{var r,a;return{nodes:Ee(Te(Ue(e,t,new Set([n])),(e=>e!==n))),components:F(null!==(r=null===(a=o.nodeToComponentSubscriptions.get(n))||void 0===a?void 0:a.values())&&void 0!==r?r:[],(([e])=>({name:e})))}}})},getDownstreamNodes:Ue};const xe=null!==(Be=o.createMutableSource)&&void 0!==Be?Be:o.unstable_createMutableSource,Pe=null!==(De=o.useMutableSource)&&void 0!==De?De:o.unstable_useMutableSource,ze=null!==(Oe=o.useSyncExternalStore)&&void 0!==Oe?Oe:o.unstable_useSyncExternalStore;var Fe={createMutableSource:xe,useMutableSource:Pe,useSyncExternalStore:ze,reactMode:function(){return z("recoil_transition_support")?{mode:"TRANSITION_SUPPORT",early:!0,concurrent:!0}:z("recoil_sync_external_store")&&null!=ze?{mode:"SYNC_EXTERNAL_STORE",early:!0,concurrent:!1}:z("recoil_mutable_source")&&null!=Pe&&"undefined"!==typeof window&&!window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE?z("recoil_suppress_rerender_in_callback")?{mode:"MUTABLE_SOURCE",early:!0,concurrent:!0}:{mode:"MUTABLE_SOURCE",early:!1,concurrent:!1}:z("recoil_suppress_rerender_in_callback")?{mode:"LEGACY",early:!0,concurrent:!1}:{mode:"LEGACY",early:!1,concurrent:!1}}};const{getDownstreamNodes:je,getNodeLoadable:We,setNodeValue:$e}=Ie,{getNextComponentID:Ge}=he,{getNode:He,getNodeMaybe:qe}=J,{DefaultValue:Ke,RecoilValueNotReady:Ze}=J,{reactMode:Ye}=Fe,{AbstractRecoilValue:Je,RecoilState:Xe,RecoilValueReadOnly:Qe,isRecoilValue:et}=O;function tt(e,t,n){if("set"===n.type){const{recoilValue:o,valueOrUpdater:r}=n,a=function(e,t,{key:n},o){if("function"===typeof o){const r=We(e,t,n);if("loading"===r.state)throw new Ze(n);if("hasError"===r.state)throw r.contents;return o(r.contents)}return o}(e,t,o,r),i=$e(e,t,o.key,a);for(const[e,n]of i.entries())nt(t,e,n)}else if("setLoadable"===n.type){const{recoilValue:{key:e},loadable:o}=n;nt(t,e,o)}else if("markModified"===n.type){const{recoilValue:{key:e}}=n;t.dirtyAtoms.add(e)}else if("setUnvalidated"===n.type){var o;const{recoilValue:{key:e},unvalidatedValue:r}=n,a=qe(e);null===a||void 0===a||null===(o=a.invalidate)||void 0===o||o.call(a,t),t.atomValues.delete(e),t.nonvalidatedAtoms.set(e,r),t.dirtyAtoms.add(e)}else j(`Unknown action ${n.type}`)}function nt(e,t,n){"hasValue"===n.state&&n.contents instanceof Ke?e.atomValues.delete(t):e.atomValues.set(t,n),e.dirtyAtoms.add(t),e.nonvalidatedAtoms.delete(t)}function ot(e,t){e.replaceState((n=>{const o=it(n);for(const r of t)tt(e,o,r);return st(e,o),o}))}function rt(e,t){if(at.length){const n=at[at.length-1];let o=n.get(e);o||n.set(e,o=[]),o.push(t)}else ot(e,[t])}const at=[];function it(e){return{...e,atomValues:e.atomValues.clone(),nonvalidatedAtoms:e.nonvalidatedAtoms.clone(),dirtyAtoms:new Set(e.dirtyAtoms)}}function st(e,t){const n=je(e,t,t.dirtyAtoms);for(const a of n){var o,r;null===(o=qe(a))||void 0===o||null===(r=o.invalidate)||void 0===r||r.call(o,t)}}function ut(e,t,n){rt(e,{type:"set",recoilValue:t,valueOrUpdater:n})}var ct={RecoilValueReadOnly:Qe,AbstractRecoilValue:Je,RecoilState:Xe,getRecoilValueAsLoadable:function(e,{key:t},n=e.getState().currentTree){var o,r;const a=e.getState();n.version!==a.currentTree.version&&n.version!==(null===(o=a.nextTree)||void 0===o?void 0:o.version)&&n.version!==(null===(r=a.previousTree)||void 0===r?void 0:r.version)&&j("Tried to read from a discarded tree");const i=We(e,n,t);return"loading"===i.state&&i.contents.catch((()=>{})),i},setRecoilValue:ut,setRecoilValueLoadable:function(e,t,n){if(n instanceof Ke)return ut(e,t,n);rt(e,{type:"setLoadable",recoilValue:t,loadable:n})},markRecoilValueModified:function(e,t){rt(e,{type:"markModified",recoilValue:t})},setUnvalidatedRecoilValue:function(e,t,n){rt(e,{type:"setUnvalidated",recoilValue:t,unvalidatedValue:n})},subscribeToRecoilValue:function(e,{key:t},n,o=null){const r=Ge(),a=e.getState();a.nodeToComponentSubscriptions.has(t)||a.nodeToComponentSubscriptions.set(t,new Map),s(a.nodeToComponentSubscriptions.get(t)).set(r,[null!==o&&void 0!==o?o:"<not captured>",n]);const i=Ye();if(i.early&&("LEGACY"===i.mode||"MUTABLE_SOURCE"===i.mode)){const o=e.getState().nextTree;o&&o.dirtyAtoms.has(t)&&n(o)}return{release:()=>{const n=e.getState(),o=n.nodeToComponentSubscriptions.get(t);void 0!==o&&o.has(r)?(o.delete(r),0===o.size&&n.nodeToComponentSubscriptions.delete(t)):j(`Subscription missing at release time for atom ${t}. This is a bug in Recoil.`)}}},isRecoilValue:et,applyAtomValueWrites:function(e,t){const n=e.clone();return t.forEach(((e,t)=>{"hasValue"===e.state&&e.contents instanceof Ke?n.delete(t):n.set(t,e)})),n},batchStart:function(){const e=new Map;return at.push(e),()=>{for(const[t,n]of e)ot(t,n);at.pop()!==e&&j("Incorrect order of batch popping")}},writeLoadableToTreeState:nt,invalidateDownstreams:st,copyTreeState:it,refreshRecoilValue:function(e,t){var n;const{currentTree:o}=e.getState(),r=He(t.key);null===(n=r.clearCache)||void 0===n||n.call(r,e,o)},invalidateDownstreams_FOR_TESTING:st};var lt=function(e,t,n){const o=e.entries();let r=o.next();for(;!r.done;){const a=r.value;if(t.call(n,a[1],a[0],e))return!0;r=o.next()}return!1};const{cleanUpNode:dt}=Ie,{deleteNodeConfigIfPossible:ft,getNode:ht}=J,{RetentionZone:pt}=Se,vt=new Set;function yt(e,t){const n=e.getState(),o=n.currentTree;if(n.nextTree)return void j("releaseNodesNowOnCurrentTree should only be called at the end of a batch");const r=new Set;for(const i of t)if(i instanceof pt)for(const e of _t(n,i))r.add(e);else r.add(i);const a=function(e,t){const n=e.getState(),o=n.currentTree,r=e.getGraph(o.version),a=new Set,i=new Set;return u(t),a;function u(t){const c=new Set,l=function(e,t,n,o,r){const a=e.getGraph(t.version),i=[],u=new Set;for(;n.size>0;)c(s(n.values().next().value));return i;function c(e){if(o.has(e)||r.has(e))return void n.delete(e);if(u.has(e))return;const t=a.nodeToNodeSubscriptions.get(e);if(t)for(const n of t)c(n);u.add(e),n.delete(e),i.push(e)}}(e,o,t,a,i);for(const e of l){var d;if("recoilRoot"===ht(e).retainedBy){i.add(e);continue}if((null!==(d=n.retention.referenceCounts.get(e))&&void 0!==d?d:0)>0){i.add(e);continue}if(gt(e).some((e=>n.retention.referenceCounts.get(e)))){i.add(e);continue}const t=r.nodeToNodeSubscriptions.get(e);t&&lt(t,(e=>i.has(e)))?i.add(e):(a.add(e),c.add(e))}const f=new Set;for(const e of c)for(const t of null!==(h=r.nodeDeps.get(e))&&void 0!==h?h:vt){var h;a.has(t)||f.add(t)}f.size&&u(f)}}(e,r);for(const i of a)mt(e,o,i)}function mt(e,t,n){if(!z("recoil_memory_managament_2020"))return;dt(e,n);const o=e.getState();o.knownAtoms.delete(n),o.knownSelectors.delete(n),o.nodeTransactionSubscriptions.delete(n),o.retention.referenceCounts.delete(n);const r=gt(n);for(const u of r){var a;null===(a=o.retention.nodesRetainedByZone.get(u))||void 0===a||a.delete(n)}t.atomValues.delete(n),t.dirtyAtoms.delete(n),t.nonvalidatedAtoms.delete(n);const i=o.graphsByVersion.get(t.version);if(i){const e=i.nodeDeps.get(n);if(void 0!==e){i.nodeDeps.delete(n);for(const t of e){var s;null===(s=i.nodeToNodeSubscriptions.get(t))||void 0===s||s.delete(n)}}i.nodeToNodeSubscriptions.delete(n)}ft(n)}function _t(e,t){var n;return null!==(n=e.retention.nodesRetainedByZone.get(t))&&void 0!==n?n:vt}function gt(e){const t=ht(e).retainedBy;return void 0===t||"components"===t||"recoilRoot"===t?[]:t instanceof pt?[t]:t}function St(e,t){if(!z("recoil_memory_managament_2020"))return;e.getState().retention.referenceCounts.delete(t),function(e,t){const n=e.getState();n.nextTree?n.retention.retainablesToCheckForRelease.add(t):yt(e,new Set([t]))}(e,t)}var bt={SUSPENSE_TIMEOUT_MS:12e4,updateRetainCount:function(e,t,n){var o;if(!z("recoil_memory_managament_2020"))return;const r=e.getState().retention.referenceCounts,a=(null!==(o=r.get(t))&&void 0!==o?o:0)+n;0===a?St(e,t):r.set(t,a)},updateRetainCountToZero:St,releaseScheduledRetainablesNow:function(e){if(!z("recoil_memory_managament_2020"))return;const t=e.getState();yt(e,t.retention.retainablesToCheckForRelease),t.retention.retainablesToCheckForRelease.clear()},retainedByOptionWithDefault:function(e){return void 0===e?"recoilRoot":e}};const{unstable_batchedUpdates:Tt}=r;var wt={unstable_batchedUpdates:Tt};const{unstable_batchedUpdates:Rt}=wt;var At={unstable_batchedUpdates:Rt};const{batchStart:Et}=ct,{unstable_batchedUpdates:Nt}=At;let kt=Nt;var Vt={getBatcher:()=>kt,setBatcher:e=>{kt=e},batchUpdates:e=>{kt((()=>{let t=()=>{};try{t=Et(),e()}finally{t()}}))}};var Lt=function*(e){for(const t of e)for(const e of t)yield e};var Mt={isSSR:"undefined"===typeof window,isReactNative:"undefined"!==typeof navigator&&"ReactNative"===navigator.product};var Ct={memoizeWithArgsHash:function(e,t){let n;return(...o)=>{n||(n={});const r=t(...o);return Object.hasOwnProperty.call(n,r)||(n[r]=e.apply(this,o)),n[r]}},memoizeOneWithArgsHash:function(e,t){let n,o;return(...r)=>{const a=t(...r);return n===a||(n=a,o=e.apply(this,r)),o}},memoizeOneWithArgsHashAndInvalidation:function(e,t){let n,o;return[(...r)=>{const a=t(...r);return n===a||(n=a,o=e.apply(this,r)),o},()=>{n=null}]}};const{batchUpdates:Ut}=Vt,{initializeNode:Bt,peekNodeInfo:Dt}=Ie,{graph:Ot}=ce,{getNextStoreID:It}=he,{DEFAULT_VALUE:xt,recoilValues:Pt,recoilValuesForKeys:zt}=J,{AbstractRecoilValue:Ft,getRecoilValueAsLoadable:jt,setRecoilValue:Wt,setUnvalidatedRecoilValue:$t}=ct,{updateRetainCount:Gt}=bt,{getNextTreeStateVersion:Ht,makeEmptyStoreState:qt}=_e,{isSSR:Kt}=Mt,{memoizeOneWithArgsHashAndInvalidation:Zt}=Ct;class Yt{constructor(e){u(this,"_store",void 0),u(this,"_refCount",1),u(this,"getLoadable",(e=>(this.checkRefCount_INTERNAL(),jt(this._store,e)))),u(this,"getPromise",(e=>(this.checkRefCount_INTERNAL(),this.getLoadable(e).toPromise()))),u(this,"getNodes_UNSTABLE",(e=>{if(this.checkRefCount_INTERNAL(),!0===(null===e||void 0===e?void 0:e.isModified)){if(!1===(null===e||void 0===e?void 0:e.isInitialized))return[];const t=this._store.getState().currentTree;return zt(t.dirtyAtoms)}const t=this._store.getState().knownAtoms,n=this._store.getState().knownSelectors;return null==(null===e||void 0===e?void 0:e.isInitialized)?Pt.values():!0===e.isInitialized?zt(Lt([this._store.getState().knownAtoms,this._store.getState().knownSelectors])):Te(Pt.values(),(({key:e})=>!t.has(e)&&!n.has(e)))})),u(this,"getInfo_UNSTABLE",(({key:e})=>(this.checkRefCount_INTERNAL(),Dt(this._store,this._store.getState().currentTree,e)))),u(this,"map",(e=>{this.checkRefCount_INTERNAL();const t=new en(this,Ut);return e(t),t})),u(this,"asyncMap",(async e=>{this.checkRefCount_INTERNAL();const t=new en(this,Ut);return t.retain(),await e(t),t.autoRelease_INTERNAL(),t})),this._store={storeID:It(),getState:()=>e,replaceState:t=>{e.currentTree=t(e.currentTree)},getGraph:t=>{const n=e.graphsByVersion;if(n.has(t))return s(n.get(t));const o=Ot();return n.set(t,o),o},subscribeToTransactions:()=>({release:()=>{}}),addTransactionMetadata:()=>{throw a("Cannot subscribe to Snapshots")}};for(const t of this._store.getState().knownAtoms)Bt(this._store,t,"get"),Gt(this._store,t,1);this.autoRelease_INTERNAL()}retain(){this._refCount<=0&&j("Attempt to retain() Snapshot that was already released."),this._refCount++;let e=!1;return()=>{e||(e=!0,this._release())}}autoRelease_INTERNAL(){Kt||window.setTimeout((()=>this._release()),0)}_release(){if(this._refCount--,0===this._refCount){if(this._store.getState().nodeCleanupFunctions.forEach((e=>e())),this._store.getState().nodeCleanupFunctions.clear(),!z("recoil_memory_managament_2020"))return}else this._refCount}isRetained(){return this._refCount>0}checkRefCount_INTERNAL(){z("recoil_memory_managament_2020")&&this._refCount}getStore_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store}getID(){return this.checkRefCount_INTERNAL(),this._store.getState().currentTree.stateID}}function Jt(e,t,n=!1){const o=e.getState(),r=n?Ht():t.version;return{currentTree:n?{version:r,stateID:r,transactionMetadata:{...t.transactionMetadata},dirtyAtoms:new Set(t.dirtyAtoms),atomValues:t.atomValues.clone(),nonvalidatedAtoms:t.nonvalidatedAtoms.clone()}:t,commitDepth:0,nextTree:null,previousTree:null,knownAtoms:new Set(o.knownAtoms),knownSelectors:new Set(o.knownSelectors),transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:(new Map).set(r,e.getGraph(t.version)),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map(F(o.nodeCleanupFunctions.entries(),(([e])=>[e,()=>{}])))}}const[Xt,Qt]=Zt(((e,t)=>{const n=e.getState(),o="current"===t?n.currentTree:s(n.previousTree);return new Yt(Jt(e,o))}),((e,t)=>{var n;return String(t)+String(e.storeID)+String(e.getState().currentTree.version)+String(null===(n=e.getState().previousTree)||void 0===n?void 0:n.version)}));class en extends Yt{constructor(e,t){super(Jt(e.getStore_INTERNAL(),e.getStore_INTERNAL().getState().currentTree,!0)),u(this,"_batch",void 0),u(this,"set",((e,t)=>{this.checkRefCount_INTERNAL();const n=this.getStore_INTERNAL();this._batch((()=>{Gt(n,e.key,1),Wt(this.getStore_INTERNAL(),e,t)}))})),u(this,"reset",(e=>{this.checkRefCount_INTERNAL();const t=this.getStore_INTERNAL();this._batch((()=>{Gt(t,e.key,1),Wt(this.getStore_INTERNAL(),e,xt)}))})),u(this,"setUnvalidatedAtomValues_DEPRECATED",(e=>{this.checkRefCount_INTERNAL();const t=this.getStore_INTERNAL();Ut((()=>{for(const[n,o]of e.entries())Gt(t,n,1),$t(t,new Ft(n),o)}))})),this._batch=t}}var tn={Snapshot:Yt,MutableSnapshot:en,freshSnapshot:function(e){const t=new Yt(qt());return null!=e?t.map(e):t},cloneSnapshot:function(e,t="current"){const n=Xt(e,t);return n.isRetained()?n:(Qt(),Xt(e,t))}},nn=tn.Snapshot,on=tn.MutableSnapshot,rn=tn.freshSnapshot,an=tn.cloneSnapshot,sn=Object.freeze({__proto__:null,Snapshot:nn,MutableSnapshot:on,freshSnapshot:rn,cloneSnapshot:an});var un=function(...e){const t=new Set;for(const n of e)for(const e of n)t.add(e);return t};const{useRef:cn}=o;var ln=function(e){const t=cn(e);return t.current===e&&"function"===typeof e&&(t.current=e()),t};const{getNextTreeStateVersion:dn,makeEmptyStoreState:fn}=_e,{cleanUpNode:hn,getDownstreamNodes:pn,initializeNode:vn,setNodeValue:yn,setUnvalidatedAtomValue_DEPRECATED:mn}=Ie,{graph:_n}=ce,{cloneGraph:gn}=ce,{getNextStoreID:Sn}=he,{createMutableSource:bn,reactMode:Tn}=Fe,{applyAtomValueWrites:wn}=ct,{releaseScheduledRetainablesNow:Rn}=bt,{freshSnapshot:An}=sn,{useCallback:En,useContext:Nn,useEffect:kn,useMemo:Vn,useRef:Ln,useState:Mn}=o;function Cn(){throw a("This component must be used inside a <RecoilRoot> component.")}const Un=Object.freeze({storeID:Sn(),getState:Cn,replaceState:Cn,getGraph:Cn,subscribeToTransactions:Cn,addTransactionMetadata:Cn});let Bn=!1;function Dn(e){if(Bn)throw a("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.");const t=e.getState();if(null===t.nextTree){z("recoil_memory_managament_2020")&&z("recoil_release_on_cascading_update_killswitch_2021")&&t.commitDepth>0&&Rn(e);const n=t.currentTree.version,o=dn();t.nextTree={...t.currentTree,version:o,stateID:o,dirtyAtoms:new Set,transactionMetadata:{}},t.graphsByVersion.set(o,gn(s(t.graphsByVersion.get(n))))}}const On=o.createContext({current:Un}),In=()=>Nn(On),xn=o.createContext(null);function Pn(e,t,n){const o=pn(e,n,n.dirtyAtoms);for(const r of o){const e=t.nodeToComponentSubscriptions.get(r);if(e)for(const[t,[o,r]]of e)r(n)}}function zn(e){const t=e.getState(),n=t.currentTree,o=n.dirtyAtoms;if(o.size){for(const[n,r]of t.nodeTransactionSubscriptions)if(o.has(n))for(const[t,o]of r)o(e);for(const[n,o]of t.transactionSubscriptions)o(e);(!Tn().early||t.suspendedComponentResolvers.size>0)&&(Pn(e,t,n),t.suspendedComponentResolvers.forEach((e=>e())),t.suspendedComponentResolvers.clear())}t.queuedComponentCallbacks_DEPRECATED.forEach((e=>e(n))),t.queuedComponentCallbacks_DEPRECATED.splice(0,t.queuedComponentCallbacks_DEPRECATED.length)}function Fn({setNotifyBatcherOfChange:e}){const t=In(),[,n]=Mn([]);return e((()=>n({}))),kn((()=>(e((()=>n({}))),()=>{e((()=>{}))})),[e]),kn((()=>{X.enqueueExecution("Batcher",(()=>{!function(e){const t=e.getState();t.commitDepth++;try{const{nextTree:n}=t;if(null===n)return;t.previousTree=t.currentTree,t.currentTree=n,t.nextTree=null,zn(e),null!=t.previousTree?t.graphsByVersion.delete(t.previousTree.version):j("Ended batch with no previous state, which is unexpected","recoil"),t.previousTree=null,z("recoil_memory_managament_2020")&&Rn(e)}finally{t.commitDepth--}}(t.current)}))})),null}let jn=0;function Wn({initializeState_DEPRECATED:e,initializeState:t,store_INTERNAL:n,children:r}){let a;const i=e=>{const t=a.current.graphsByVersion;if(t.has(e))return s(t.get(e));const n=_n();return t.set(e,n),n},u=(e,t)=>{if(null==t){const{transactionSubscriptions:t}=h.current.getState(),n=jn++;return t.set(n,e),{release:()=>{t.delete(n)}}}{const{nodeTransactionSubscriptions:n}=h.current.getState();n.has(t)||n.set(t,new Map);const o=jn++;return s(n.get(t)).set(o,e),{release:()=>{const e=n.get(t);e&&(e.delete(o),0===e.size&&n.delete(t))}}}},c=e=>{Dn(h.current);for(const t of Object.keys(e))s(h.current.getState().nextTree).transactionMetadata[t]=e[t]},l=e=>{Dn(h.current);const t=s(a.current.nextTree);let n;try{Bn=!0,n=e(t)}finally{Bn=!1}n!==t&&(a.current.nextTree=n,Tn().early&&Pn(h.current,a.current,n),s(d.current)())},d=Ln(null),f=En((e=>{d.current=e}),[d]),h=ln((()=>null!==n&&void 0!==n?n:{storeID:Sn(),getState:()=>a.current,replaceState:l,getGraph:i,subscribeToTransactions:u,addTransactionMetadata:c}));null!=n&&(h.current=n),a=ln((()=>null!=e?function(e,t){const n=fn();return t({set:(t,o)=>{const r=n.currentTree,a=yn(e,r,t.key,o),i=new Set(a.keys()),s=r.nonvalidatedAtoms.clone();for(const e of i)s.delete(e);n.currentTree={...r,dirtyAtoms:un(r.dirtyAtoms,i),atomValues:wn(r.atomValues,a),nonvalidatedAtoms:s}},setUnvalidatedAtomValues:e=>{e.forEach(((e,t)=>{n.currentTree=mn(n.currentTree,t,e)}))}}),n}(h.current,e):null!=t?function(e){const t=An().map(e),n=t.getStore_INTERNAL().getState();return t.retain(),n.nodeCleanupFunctions.forEach((e=>e())),n.nodeCleanupFunctions.clear(),n}(t):fn()));const p=Vn((()=>null===bn||void 0===bn?void 0:bn(a,(()=>a.current.currentTree.version))),[a]);return kn((()=>{const e=h.current;for(const t of new Set(e.getState().knownAtoms))vn(e,t,"get");return()=>{for(const t of e.getState().knownAtoms)hn(e,t)}}),[h]),o.createElement(On.Provider,{value:h},o.createElement(xn.Provider,{value:p},o.createElement(Fn,{setNotifyBatcherOfChange:f}),r))}var $n={RecoilRoot:function(e){const{override:t,...n}=e,r=In();return!1===t&&r.current!==Un?e.children:o.createElement(Wn,n)},useStoreRef:In,useRecoilMutableSource:function(){const e=Nn(xn);return null==e&&I("Attempted to use a Recoil hook outside of a <RecoilRoot>. <RecoilRoot> must be an ancestor of any component that uses Recoil hooks."),e},useRecoilStoreID:function(){return In().current.storeID},notifyComponents_FOR_TESTING:Pn,sendEndOfBatchNotifications_FOR_TESTING:zn};var Gn=function(e,t){if(e===t)return!0;if(e.length!==t.length)return!1;for(let n=0,o=e.length;n<o;n++)if(e[n]!==t[n])return!1;return!0};const{useEffect:Hn,useRef:qn}=o;var Kn=function(e){const t=qn();return Hn((()=>{t.current=e})),t.current};const{useStoreRef:Zn}=$n,{SUSPENSE_TIMEOUT_MS:Yn}=bt,{updateRetainCount:Jn}=bt,{RetentionZone:Xn}=Se,{useEffect:Qn,useRef:eo}=o,{isSSR:to}=Mt;var no=function(e){if(z("recoil_memory_managament_2020"))return function(e){const t=(Array.isArray(e)?e:[e]).map((e=>e instanceof Xn?e:e.key)),n=Zn();Qn((()=>{if(!z("recoil_memory_managament_2020"))return;const e=n.current;if(o.current&&!to)window.clearTimeout(o.current),o.current=null;else for(const n of t)Jn(e,n,1);return()=>{for(const n of t)Jn(e,n,-1)}}),[n,...t]);const o=eo(),r=Kn(t);if(!to&&(void 0===r||!Gn(r,t))){const e=n.current;for(const n of t)Jn(e,n,1);if(r)for(const t of r)Jn(e,t,-1);o.current&&window.clearTimeout(o.current),o.current=window.setTimeout((()=>{o.current=null;for(const n of t)Jn(e,n,-1)}),Yn)}}(e)};const{useRef:oo}=o;var ro=function(){return oo(),"<component name not available>"};const{batchUpdates:ao}=Vt,{DEFAULT_VALUE:io}=J,{reactMode:so,useMutableSource:uo,useSyncExternalStore:co}=Fe,{useRecoilMutableSource:lo,useStoreRef:fo}=$n,{isRecoilValue:ho}=O,{AbstractRecoilValue:po,getRecoilValueAsLoadable:vo,setRecoilValue:yo,setUnvalidatedRecoilValue:mo,subscribeToRecoilValue:_o}=ct,{useCallback:go,useEffect:So,useMemo:bo,useRef:To,useState:wo}=o,{setByAddingToSet:Ro}=be;function Ao(e,t,n){if("hasValue"===e.state)return e.contents;if("loading"===e.state){throw new Promise((e=>{n.current.getState().suspendedComponentResolvers.add(e)}))}throw"hasError"===e.state?e.contents:a(`Invalid value of loadable atom "${t.key}"`)}function Eo(e){const t=fo(),n=ro(),o=go((()=>{var n;const o=t.current,r=o.getState(),a=so().early&&null!==(n=r.nextTree)&&void 0!==n?n:r.currentTree;return{loadable:vo(o,e,a),key:e.key}}),[t,e]),r=go((e=>{let t;return()=>{var n,o;const r=e();return null!==(n=t)&&void 0!==n&&n.loadable.is(r.loadable)&&(null===(o=t)||void 0===o?void 0:o.key)===r.key?t:(t=r,r)}}),[]),a=bo((()=>r(o)),[o,r]),i=go((o=>{const r=t.current;return _o(r,e,o,n).release}),[t,e,n]);return co(i,a,a).loadable}function No(e){const t=fo(),n=go((()=>{var n;const o=t.current,r=o.getState(),a=so().early&&null!==(n=r.nextTree)&&void 0!==n?n:r.currentTree;return vo(o,e,a)}),[t,e]),o=go((()=>n()),[n]),r=ro(),i=go(((o,a)=>{const i=t.current;return _o(i,e,(()=>{if(!z("recoil_suppress_rerender_in_callback"))return a();const e=n();c.current.is(e)||a(),c.current=e}),r).release}),[t,e,r,n]),s=lo();if(null==s)throw a("Recoil hooks must be used in components contained within a <RecoilRoot> component.");const u=uo(s,o,i),c=To(u);return So((()=>{c.current=u})),u}function ko(e){const t=fo(),n=ro(),o=go((()=>{var n;const o=t.current,r=o.getState(),a=so().early&&null!==(n=r.nextTree)&&void 0!==n?n:r.currentTree;return vo(o,e,a)}),[t,e]),r=go((()=>({loadable:o(),key:e.key})),[o,e.key]),a=go((e=>{const t=r();return e.loadable.is(t.loadable)&&e.key===t.key?e:t}),[r]);So((()=>{const o=_o(t.current,e,(e=>{s(a)}),n);return s(a),o.release}),[n,e,t,a]);const[i,s]=wo(r);return i.key!==e.key?r().loadable:i.loadable}function Vo(e){const t=fo(),[,n]=wo([]),o=ro(),r=go((()=>{var n;const o=t.current,r=o.getState(),a=so().early&&null!==(n=r.nextTree)&&void 0!==n?n:r.currentTree;return vo(o,e,a)}),[t,e]),a=r(),i=To(a);return So((()=>{i.current=a})),So((()=>{const a=t.current,s=a.getState(),u=_o(a,e,(e=>{var t;if(!z("recoil_suppress_rerender_in_callback"))return n([]);const o=r();null!==(t=i.current)&&void 0!==t&&t.is(o)||n(o),i.current=o}),o);if(s.nextTree)a.getState().queuedComponentCallbacks_DEPRECATED.push((()=>{i.current=null,n([])}));else{var c;if(!z("recoil_suppress_rerender_in_callback"))return n([]);const e=r();null!==(c=i.current)&&void 0!==c&&c.is(e)||n(e),i.current=e}return u.release}),[o,r,e,t]),a}function Lo(e){return z("recoil_memory_managament_2020")&&no(e),{TRANSITION_SUPPORT:ko,SYNC_EXTERNAL_STORE:Eo,MUTABLE_SOURCE:No,LEGACY:Vo}[so().mode](e)}function Mo(e){const t=fo();return Ao(Lo(e),e,t)}function Co(e){const t=fo();return go((n=>{yo(t.current,e,n)}),[t,e])}function Uo(e){return z("recoil_memory_managament_2020")&&no(e),ko(e)}function Bo(e){const t=fo();return Ao(Uo(e),e,t)}var Do={recoilComponentGetRecoilValueCount_FOR_TESTING:{current:0},useRecoilInterface:function(){const e=ro(),t=fo(),[,n]=wo([]),o=To(new Set);o.current=new Set;const r=To(new Set),a=To(new Map),i=go((e=>{const t=a.current.get(e);t&&(t.release(),a.current.delete(e))}),[a]),s=go(((e,t)=>{a.current.has(t)&&n([])}),[]);return So((()=>{const n=t.current;ie(o.current,r.current).forEach((t=>{if(a.current.has(t))return void I(`Double subscription to RecoilValue "${t}"`);const o=_o(n,new po(t),(e=>s(e,t)),e);a.current.set(t,o);n.getState().nextTree?n.getState().queuedComponentCallbacks_DEPRECATED.push((()=>{s(n.getState(),t)})):s(n.getState(),t)})),ie(r.current,o.current).forEach((e=>{i(e)})),r.current=o.current})),So((()=>{const n=a.current;return ie(o.current,new Set(n.keys())).forEach((o=>{const r=_o(t.current,new po(o),(e=>s(e,o)),e);n.set(o,r)})),()=>n.forEach(((e,t)=>i(t)))}),[e,t,i,s]),bo((()=>{function e(e){return n=>{yo(t.current,e,n)}}function n(e){var n;o.current.has(e.key)||(o.current=Ro(o.current,e.key));const r=t.current.getState();return vo(t.current,e,so().early&&null!==(n=r.nextTree)&&void 0!==n?n:r.currentTree)}function r(e){return Ao(n(e),e,t)}return{getRecoilValue:r,getRecoilValueLoadable:n,getRecoilState:function(t){return[r(t),e(t)]},getRecoilStateLoadable:function(t){return[n(t),e(t)]},getSetRecoilState:e,getResetRecoilState:function(e){return()=>yo(t.current,e,io)}}}),[o,t])},useRecoilState:function(e){return[Mo(e),Co(e)]},useRecoilStateLoadable:function(e){return[Lo(e),Co(e)]},useRecoilValue:Mo,useRecoilValueLoadable:Lo,useResetRecoilState:function(e){const t=fo();return go((()=>{yo(t.current,e,io)}),[t,e])},useSetRecoilState:Co,useSetUnvalidatedAtomValues:function(){const e=fo();return(t,n={})=>{ao((()=>{e.current.addTransactionMetadata(n),t.forEach(((t,n)=>mo(e.current,new po(n),t)))}))}},useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:Uo,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:Bo,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:function(e){return[Bo(e),Co(e)]}};var Oo=function(e,t){const n=new Map;for(const[o,r]of e)t(r,o)&&n.set(o,r);return n};var Io=function(e,t){const n=new Set;for(const o of e)t(o)&&n.add(o);return n};var xo=function(...e){const t=new Map;for(let n=0;n<e.length;n++){const o=e[n].keys();let r;for(;!(r=o.next()).done;)t.set(r.value,e[n].get(r.value))}return t};const{batchUpdates:Po}=Vt,{DEFAULT_VALUE:zo,getNode:Fo,nodes:jo}=J,{useStoreRef:Wo}=$n,{AbstractRecoilValue:$o,setRecoilValueLoadable:Go}=ct,{SUSPENSE_TIMEOUT_MS:Ho}=bt,{cloneSnapshot:qo}=sn,{useCallback:Ko,useEffect:Zo,useRef:Yo,useState:Jo}=o,{isSSR:Xo}=Mt;function Qo(e){const t=Wo();Zo((()=>t.current.subscribeToTransactions(e).release),[e,t])}function er(e){const t=e.atomValues.toMap(),n=se(Oo(t,((e,t)=>{const n=Fo(t).persistence_UNSTABLE;return null!=n&&"none"!==n.type&&"hasValue"===e.state})),(e=>e.contents));return xo(e.nonvalidatedAtoms.toMap(),n)}function tr(e,t){var n;const o=e.getState(),r=null!==(n=o.nextTree)&&void 0!==n?n:o.currentTree,a=t.getStore_INTERNAL().getState().currentTree;Po((()=>{const n=new Set;for(const e of[r.atomValues.keys(),a.atomValues.keys()])for(const t of e){var o,i;(null===(o=r.atomValues.get(t))||void 0===o?void 0:o.contents)!==(null===(i=a.atomValues.get(t))||void 0===i?void 0:i.contents)&&Fo(t).shouldRestoreFromSnapshots&&n.add(t)}n.forEach((t=>{Go(e,new $o(t),a.atomValues.has(t)?s(a.atomValues.get(t)):zo)})),e.replaceState((e=>({...e,stateID:t.getID()})))}))}var nr={useRecoilSnapshot:function(){const e=Wo(),[t,n]=Jo((()=>qo(e.current))),o=Kn(t),r=Yo(),a=Yo();if(Qo(Ko((e=>n(qo(e))),[])),Zo((()=>{const e=t.retain();var n;r.current&&!Xo&&(window.clearTimeout(r.current),r.current=null,null===(n=a.current)||void 0===n||n.call(a),a.current=null);return e}),[t]),o!==t&&!Xo){var i;if(r.current)window.clearTimeout(r.current),r.current=null,null===(i=a.current)||void 0===i||i.call(a),a.current=null;a.current=t.retain(),r.current=window.setTimeout((()=>{var e;r.current=null,null===(e=a.current)||void 0===e||e.call(a),a.current=null}),Ho)}return t},gotoSnapshot:tr,useGotoRecoilSnapshot:function(){const e=Wo();return Ko((t=>tr(e.current,t)),[e])},useRecoilTransactionObserver:function(e){Qo(Ko((t=>{const n=qo(t,"current"),o=qo(t,"previous");e({snapshot:n,previousSnapshot:o})}),[e]))},useTransactionObservation_DEPRECATED:function(e){Qo(Ko((t=>{let n=t.getState().previousTree;const o=t.getState().currentTree;n||(j("Transaction subscribers notified without a previous tree being present -- this is a bug in Recoil"),n=t.getState().currentTree);const r=er(o),a=er(n),i=se(jo,(e=>{var t,n,o,r;return{persistence_UNSTABLE:{type:null!==(t=null===(n=e.persistence_UNSTABLE)||void 0===n?void 0:n.type)&&void 0!==t?t:"none",backButton:null!==(o=null===(r=e.persistence_UNSTABLE)||void 0===r?void 0:r.backButton)&&void 0!==o&&o}}})),s=Io(o.dirtyAtoms,(e=>r.has(e)||a.has(e)));e({atomValues:r,previousAtomValues:a,atomInfo:i,modifiedAtoms:s,transactionMetadata:{...o.transactionMetadata}})}),[e]))},useTransactionSubscription_DEPRECATED:Qo};const{peekNodeInfo:or}=Ie,{useStoreRef:rr}=$n;var ar=function(){const e=rr();return({key:t})=>or(e.current,e.current.getState().currentTree,t)};const{reactMode:ir}=Fe,{RecoilRoot:sr,useStoreRef:ur}=$n,{useMemo:cr}=o;var lr=function(){"MUTABLE_SOURCE"===ir().mode&&console.warn("Warning: There are known issues using useRecoilBridgeAcrossReactRoots() in recoil_mutable_source rendering mode.  Please consider upgrading to recoil_sync_external_store mode.");const e=ur().current;return cr((()=>function({children:t}){return o.createElement(sr,{store_INTERNAL:e},t)}),[e])};const{loadableWithValue:dr}=N,{initializeNode:fr}=Ie,{DEFAULT_VALUE:hr,getNode:pr}=J,{copyTreeState:vr,getRecoilValueAsLoadable:yr,invalidateDownstreams:mr,writeLoadableToTreeState:_r}=ct;function gr(e){return"atom"===pr(e.key).nodeType}class Sr{constructor(e,t){u(this,"_store",void 0),u(this,"_treeState",void 0),u(this,"_changes",void 0),u(this,"get",(e=>{if(this._changes.has(e.key))return this._changes.get(e.key);if(!gr(e))throw a("Reading selectors within atomicUpdate is not supported");const t=yr(this._store,e,this._treeState);if("hasValue"===t.state)return t.contents;throw"hasError"===t.state?t.contents:a(`Expected Recoil atom ${e.key} to have a value, but it is in a loading state.`)})),u(this,"set",((e,t)=>{if(!gr(e))throw a("Setting selectors within atomicUpdate is not supported");if("function"===typeof t){const n=this.get(e);this._changes.set(e.key,t(n))}else fr(this._store,e.key,"set"),this._changes.set(e.key,t)})),u(this,"reset",(e=>{this.set(e,hr)})),this._store=e,this._treeState=t,this._changes=new Map}newTreeState_INTERNAL(){if(0===this._changes.size)return this._treeState;const e=vr(this._treeState);for(const[t,n]of this._changes)_r(e,t,dr(n));return mr(this._store,e),e}}var br=function(e){return t=>{e.replaceState((n=>{const o=new Sr(e,n);return t(o),o.newTreeState_INTERNAL()}))}},Tr=Object.freeze({__proto__:null,atomicUpdater:br});var wr=function(e,t){if(!e)throw new Error(t)};const{atomicUpdater:Rr}=Tr,{batchUpdates:Ar}=Vt,{DEFAULT_VALUE:Er}=J,{useStoreRef:Nr}=$n,{refreshRecoilValue:kr,setRecoilValue:Vr}=ct,{Snapshot:Lr,cloneSnapshot:Mr}=sn,{gotoSnapshot:Cr}=nr,{useCallback:Ur}=o;class Br{}const Dr=new Br;function Or(e,t,n,o){let r=Dr;return Ar((()=>{const i="useRecoilCallback() expects a function that returns a function: it accepts a function of the type (RecoilInterface) => (Args) => ReturnType and returns a callback function (Args) => ReturnType, where RecoilInterface is an object {snapshot, set, ...} and Args and ReturnType are the argument and return types of the callback you want to create.  Please see the docs at recoiljs.org for details.";if("function"!==typeof t)throw a(i);const s=we({...null!==o&&void 0!==o?o:{},set:(t,n)=>Vr(e,t,n),reset:t=>Vr(e,t,Er),refresh:t=>kr(e,t),gotoSnapshot:t=>Cr(e,t),transact_UNSTABLE:t=>Rr(e)(t)},{snapshot:()=>Mr(e)}),u=t(s);if("function"!==typeof u)throw a(i);r=u(...n)})),r instanceof Br&&wr(!1),r}var Ir={recoilCallback:Or,useRecoilCallback:function(e,t){const n=Nr();return Ur(((...t)=>Or(n.current,e,t)),null!=t?[...t,n]:void 0)}};const{useStoreRef:xr}=$n,{refreshRecoilValue:Pr}=ct,{useCallback:zr}=o;var Fr=function(e){const t=xr();return zr((()=>{const n=t.current;Pr(n,e)}),[e,t])};const{atomicUpdater:jr}=Tr,{useStoreRef:Wr}=$n,{useMemo:$r}=o;var Gr=function(e,t){const n=Wr();return $r((()=>(...t)=>{jr(n.current)((n=>{e(n)(...t)}))}),null!=t?[...t,n]:void 0)};const Hr=(e,t,n)=>{var o;if(null==e)return;if(null===n||void 0===n||null===(o=n.onNodeVisit)||void 0===o||o.call(n,e),"leaf"===e.type)return e;const r=t(e.nodeKey);return Hr(e.branches.get(r),t,n)},qr=(e,t,n,o,r,a,i)=>{var s;let u;if(null==e)if(0===t.length)u={type:"leaf",value:o,parent:n,branchKey:r};else{const[e,...s]=t,[c,l]=e;u={type:"branch",nodeKey:c,parent:n,branches:new Map,branchKey:r},u.branches.set(l,qr(null,s,u,o,l,a,i))}else if(u=e,t.length){const[n,...r]=t,[s,c]=n;if("branch"!==e.type||e.nodeKey!==s)return j("Existing cache must have a branch midway through the route with matching node key. Resetting cache."),i(),u;e.branches.set(c,qr(e.branches.get(c),r,e,o,c,a,i))}return null===a||void 0===a||null===(s=a.onNodeVisit)||void 0===s||s.call(a,u),u},Kr=(e,t,n)=>n?(n.branches.delete(t.branchKey),Zr(e,n,n.parent)):e===t,Zr=(e,t,n)=>n?(0===t.branches.size&&n.branches.delete(t.branchKey),Zr(e,n,n.parent)):e===t,Yr=e=>"leaf"===e.type?1:Array.from(e.branches.values()).reduce(((e,t)=>e+Yr(t)),0);var Jr=class{constructor(e){var t,n,o;u(this,"_numLeafs",void 0),u(this,"_root",void 0),u(this,"_onHit",void 0),u(this,"_onSet",void 0),u(this,"_mapNodeValue",void 0),this._numLeafs=0,this._root=null,this._onHit=null!==(t=null===e||void 0===e?void 0:e.onHit)&&void 0!==t?t:()=>{},this._onSet=null!==(n=null===e||void 0===e?void 0:e.onSet)&&void 0!==n?n:()=>{},this._mapNodeValue=null!==(o=null===e||void 0===e?void 0:e.mapNodeValue)&&void 0!==o?o:e=>e}size(){return this._numLeafs}root(){return this._root}get(e,t){var n;return null===(n=this.getLeafNode(e,t))||void 0===n?void 0:n.value}getLeafNode(e,t){return Hr(this.root(),(t=>this._mapNodeValue(e(t))),{onNodeVisit:e=>{null===t||void 0===t||t.onNodeVisit(e),"leaf"===e.type&&this._onHit(e)}})}set(e,t,n){let o,r=null;const a=()=>{r=qr(this.root(),e.map((([e,t])=>[e,this._mapNodeValue(t)])),null,t,null,{onNodeVisit:e=>{null===n||void 0===n||n.onNodeVisit(e),"leaf"===e.type&&(o=e)}},(()=>{this.clear(),a()}))};a(),this.root()||(this._root=r),this._numLeafs++,this._onSet(s(o))}delete(e){if(!this.root())return!1;const t=s(this.root());return!!Kr(t,e,e.parent)&&(e===t||"branch"===t.type&&!t.branches.size?(this._root=null,this._numLeafs=0,!0):(this._numLeafs-=Yr(e),!0))}clear(){this._numLeafs=0,this._root=null}},Xr=Object.freeze({__proto__:null,TreeCache:Jr});var Qr=class{constructor(e){var t;u(this,"_maxSize",void 0),u(this,"_size",void 0),u(this,"_head",void 0),u(this,"_tail",void 0),u(this,"_map",void 0),u(this,"_keyMapper",void 0),this._maxSize=e.maxSize,this._size=0,this._head=null,this._tail=null,this._map=new Map,this._keyMapper=null!==(t=e.mapKey)&&void 0!==t?t:e=>e}head(){return this._head}tail(){return this._tail}size(){return this._size}maxSize(){return this._maxSize}has(e){return this._map.has(this._keyMapper(e))}get(e){const t=this._keyMapper(e),n=this._map.get(t);if(n)return this.set(e,n.value),n.value}set(e,t){const n=this._keyMapper(e);this._map.get(n)&&this.delete(e);const o=this.head(),r={key:e,right:o,left:null,value:t};o?o.left=r:this._tail=r,this._map.set(n,r),this._head=r,this._size++,this._maybeDeleteLRU()}_maybeDeleteLRU(){this.size()>this.maxSize()&&this.deleteLru()}deleteLru(){const e=this.tail();e&&this.delete(e.key)}delete(e){const t=this._keyMapper(e);if(!this._size||!this._map.has(t))return;const n=s(this._map.get(t)),o=n.right,r=n.left;o&&(o.left=n.left),r&&(r.right=n.right),n===this.head()&&(this._head=o),n===this.tail()&&(this._tail=r),this._map.delete(t),this._size--}clear(){this._size=0,this._head=null,this._tail=null,this._map=new Map}},ea=Object.freeze({__proto__:null,LRUCache:Qr});const{LRUCache:ta}=ea,{TreeCache:na}=Xr;var oa=function(e,t=(e=>e)){const n=new ta({maxSize:e}),o=new na({mapNodeValue:t,onHit:e=>{n.set(e,!0)},onSet:t=>{const r=n.tail();n.set(t,!0),r&&o.size()>e&&o.delete(r.key)}});return o};function ra(e,t,n){if("string"===typeof e&&!e.includes('"')&&!e.includes("\\"))return`"${e}"`;switch(typeof e){case"undefined":return"";case"boolean":return e?"true":"false";case"number":case"symbol":return String(e);case"string":return JSON.stringify(e);case"function":if(!0!==(null===t||void 0===t?void 0:t.allowFunctions))throw a("Attempt to serialize function in a Recoil cache key");return`__FUNCTION(${e.name})__`}if(null===e)return"null";var o;if("object"!==typeof e)return null!==(o=JSON.stringify(e))&&void 0!==o?o:"";if(i(e))return"__PROMISE__";if(Array.isArray(e))return`[${e.map(((e,n)=>ra(e,t,n.toString())))}]`;if("function"===typeof e.toJSON)return ra(e.toJSON(n),t,n);if(e instanceof Map){const o={};for(const[n,r]of e)o["string"===typeof n?n:ra(n,t)]=r;return ra(o,t,n)}return e instanceof Set?ra(Array.from(e).sort(((e,n)=>ra(e,t).localeCompare(ra(n,t)))),t,n):void 0!==Symbol&&null!=e[Symbol.iterator]&&"function"===typeof e[Symbol.iterator]?ra(Array.from(e),t,n):`{${Object.keys(e).filter((t=>void 0!==e[t])).sort().map((n=>`${ra(n,t)}:${ra(e[n],t,n)}`)).join(",")}}`}var aa=function(e,t={allowFunctions:!1}){return ra(e,t)};const{TreeCache:ia}=Xr,sa={equality:"reference",eviction:"keep-all",maxSize:1/0};var ua=function({equality:e=sa.equality,eviction:t=sa.eviction,maxSize:n=sa.maxSize}=sa){return function(e,t,n){switch(e){case"keep-all":return new ia({mapNodeValue:n});case"lru":return oa(s(t),n);case"most-recent":return oa(1,n)}throw a(`Unrecognized eviction policy ${e}`)}(t,n,function(e){switch(e){case"reference":return e=>e;case"value":return e=>aa(e)}throw a(`Unrecognized equality policy ${e}`)}(e))};const{isReactNative:ca,isSSR:la}=Mt;var da={startPerfBlock:function(e){return()=>null}};const{loadableWithError:fa,loadableWithPromise:ha,loadableWithValue:pa}=N,{getNodeLoadable:va,peekNodeLoadable:ya,setNodeValue:ma}=Ie,{saveDependencyMapToStore:_a}=ce,{DEFAULT_VALUE:ga,RecoilValueNotReady:Sa,getConfigDeletionHandler:ba,getNode:Ta,registerNode:wa}=J,{isRecoilValue:Ra}=O,{markRecoilValueModified:Aa}=ct,{retainedByOptionWithDefault:Ea}=bt,{recoilCallback:Na}=Ir,{startPerfBlock:ka}=da;class Va{}const La=new Va,Ma=[],Ca=new Map,Ua=(()=>{let e=0;return()=>e++})();var Ba=function(e){let t=null;const{key:n,get:o,cachePolicy_UNSTABLE:r}=e,u=null!=e.set?e.set:void 0,c=new Set,l=ua(null!==r&&void 0!==r?r:{equality:"reference",eviction:"keep-all"}),d=Ea(e.retainedBy_UNSTABLE),f=new Map;let h=0;function p(){return!z("recoil_memory_managament_2020")||h>0}function v(e){return e.getState().knownSelectors.add(n),h++,()=>{h--}}function y(){return void 0!==ba(n)&&!p()}function m(e,t,n,o,r){C(t,o,r),T(e,t,new Set(r.keys()),n),_(e,n)}function _(e,n){M(e,n)&&L(e);const o=Ca.get(n);if(void 0!==o){for(const e of o)Aa(e,s(t));Ca.delete(n)}}function g(e,t){let n=Ca.get(t);null==n&&Ca.set(t,n=new Set),n.add(e)}function S(e,t,n){const o=e.getState().knownSelectors.has(n);if(o&&t.atomValues.has(n))return s(t.atomValues.get(n));const r=va(e,t,n);return"loading"!==r.state&&o&&t.atomValues.set(n,r),r}function b(e,t,n,o,r,a){return t.then((o=>{if(!p())throw L(e),La;null!=a.loadingDepKey&&a.loadingDepPromise===t?n.atomValues.set(a.loadingDepKey,pa(o)):e.getState().knownSelectors.forEach((e=>{n.atomValues.delete(e)}));const i=R(e,n);if(i&&"loading"!==i.state){if((M(e,r)||null==k(e))&&_(e,r),"hasValue"===i.state)return i.contents;throw i.contents}if(!M(e,r)){const e=E(n);if("loading"===(null===e||void 0===e?void 0:e.latestLoadable.state))return e.latestLoadable.contents}const[s,u]=w(e,n,r);if(V(e,r,u),"loading"!==s.state&&m(e,n,r,s,u),"hasError"===s.state)throw s.contents;return s.contents})).catch((t=>{if(t instanceof Va)throw La;if(!p())throw L(e),La;const a=fa(t);throw m(e,n,r,a,o),t}))}function T(e,t,o,r){var a,i,s,u,l,d,f;(M(e,r)||t.version===(null===(a=e.getState())||void 0===a||null===(i=a.currentTree)||void 0===i?void 0:i.version)||t.version===(null===(s=e.getState())||void 0===s||null===(u=s.nextTree)||void 0===u?void 0:u.version))&&(_a(new Map([[n,o]]),e,null!==(l=null===(d=e.getState())||void 0===d||null===(f=d.nextTree)||void 0===f?void 0:f.version)&&void 0!==l?l:e.getState().currentTree.version),o.forEach((e=>c.add(e))))}function w(e,r,s){const u=ka(n);let c=!0;const l=()=>{u(),c=!1};let d,f,h=!1;const v={loadingDepKey:null,loadingDepPromise:null},y=new Map,_=new Set;function g(t){const{key:n}=t;!function(e,t,n,o,r){n.add(o),T(e,t,n,r)}(e,r,_,n,s);const o=S(e,r,n);switch(y.set(n,o),o.state){case"hasValue":return o.contents;case"hasError":throw o.contents;case"loading":throw v.loadingDepKey=n,v.loadingDepPromise=o.contents,o.contents}throw a("Invalid Loadable state")}T(e,r,_,s);const w=n=>(...o)=>{if(c)throw a("Callbacks from getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can work with Recoil state without a subscription.");return null==t&&wr(!1),Na(e,n,o,{node:t})};try{d=o({get:g,getCallback:w}),d=Ra(d)?g(d):d,i(d)?d=function(e,t,n,o,r,a){return t.then((t=>{if(!p())throw L(e),La;const a=pa(t);return m(e,n,r,a,o),t})).catch((t=>{if(!p())throw L(e),La;if(V(e,r,o),i(t))return b(e,t,n,o,r,a);const s=fa(t);throw m(e,n,r,s,o),t}))}(e,d,r,y,s,v).finally(l):l()}catch(R){d=R,i(d)?d=b(e,d,r,y,s,v).finally(l):(h=!0,l())}return f=h?fa(d):i(d)?ha(d):pa(d),[f,y]}function R(e,t){const o=new Set,r=k(e);let i;try{i=l.get((n=>{"string"!==typeof n&&wr(!1);return S(e,t,n).contents}),{onNodeVisit:e=>{"branch"===e.type&&e.nodeKey!==n&&o.add(e.nodeKey)}})}catch(s){throw a(`Problem with cache lookup for selector "${n}": ${s.message}`)}return i&&T(e,t,o,null===r||void 0===r?void 0:r.latestExecutionId),i}function A(e,t){const n=Ua(),[o,r]=w(e,t,n);return"loading"===o.state?(!function(e,t,n,o,r){f.set(e,{depValuesDiscoveredSoFarDuringAsyncWork:o,latestExecutionId:t,latestLoadable:n,stateVersion:r.version})}(e,n,o,r,t),g(e,n)):(L(e),C(t,o,r)),o}function E(e){var t;const[,n]=null!==(t=Array.from(f.entries()).find((([t,n])=>null!=n.latestLoadable&&null!=n.latestExecutionId&&!function(e,t){var n,o;const r=k(e),a=null!==(n=null===r||void 0===r?void 0:r.depValuesDiscoveredSoFarDuringAsyncWork)&&void 0!==n?n:new Map,i=Array((null!==(o=N.get(t.version))&&void 0!==o?o:new Map).entries()),s=N.has(t.version)&&i.length===a.size&&i.every((([e,t])=>a.get(e)===t));if(null==a||t.version===(null===r||void 0===r?void 0:r.stateVersion)||s)return!1;return N.set(t.version,new Map(a)),Array.from(a).some((([n,o])=>S(e,t,n).contents!==o.contents))}(t,e))))&&void 0!==t?t:[];return n}const N=new Map;function k(e){return f.get(e)}function V(e,t,n){if(M(e,t)){const t=k(e);null!=t&&(t.depValuesDiscoveredSoFarDuringAsyncWork=n)}}function L(e){f.delete(e)}function M(e,t){var n;return t===(null===(n=k(e))||void 0===n?void 0:n.latestExecutionId)}function C(e,t,o){e.atomValues.set(n,t);try{l.set(function(e){return Array.from(e.entries()).map((([e,t])=>[e,t.contents]))}(o),t)}catch(r){throw a(`Problem with setting cache for selector "${n}": ${r.message}`)}}function U(e,t){return l.get((n=>{var o;return"string"!==typeof n&&wr(!1),null===(o=ya(e,t,n))||void 0===o?void 0:o.contents}))}function B(e,t){return function(e){if(Ma.includes(n)){const e=`Recoil selector has circular dependencies: ${Ma.slice(Ma.indexOf(n)).join(" \u2192 ")}`;return fa(a(e))}Ma.push(n);try{return e()}finally{Ma.pop()}}((()=>function(e,t){const n=R(e,t);if(null!=n)return L(e),n;const o=E(t);var r;return null!=o?("loading"===(null===(r=o.latestLoadable)||void 0===r?void 0:r.state)&&g(e,s(o.latestExecutionId)),s(o.latestLoadable)):A(e,t)}(e,t)))}function D(e){e.atomValues.delete(n)}function O(e,n){null==t&&wr(!1);for(const t of c){var o;const r=Ta(t);null===(o=r.clearCache)||void 0===o||o.call(r,e,n)}c.clear(),D(n),l.clear(),Aa(e,t)}if(null!=u){return t=wa({key:n,nodeType:"selector",peek:U,get:B,set:(e,t,n)=>{let o=!1;const r=new Map;function s({key:n}){if(o)throw a("Recoil: Async selector sets are not currently supported.");const r=S(e,t,n);if("hasValue"===r.state)return r.contents;throw"loading"===r.state?new Sa(n):r.contents}function c(n,i){if(o)throw a("Recoil: Async selector sets are not currently supported.");const u="function"===typeof i?i(s(n)):i;ma(e,t,n.key,u).forEach(((e,t)=>r.set(t,e)))}const l=u({set:c,get:s,reset:function(e){c(e,ga)}},n);if(void 0!==l)throw i(l)?a("Recoil: Async selector sets are not currently supported."):a("Recoil: selector set should be a void function.");return o=!0,r},init:v,invalidate:D,clearCache:O,shouldDeleteConfigOnRelease:y,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:d})}return t=wa({key:n,nodeType:"selector",peek:U,get:B,init:v,invalidate:D,clearCache:O,shouldDeleteConfigOnRelease:y,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:d})};const{loadableWithError:Da,loadableWithPromise:Oa,loadableWithValue:Ia}=N,{peekNodeInfo:xa}=Ie,{DEFAULT_VALUE:Pa,DefaultValue:za,getConfigDeletionHandler:Fa,registerNode:ja,setConfigDeletionHandler:Wa}=J,{isRecoilValue:$a}=O,{getRecoilValueAsLoadable:Ga,markRecoilValueModified:Ha,setRecoilValue:qa,setRecoilValueLoadable:Ka}=ct,{retainedByOptionWithDefault:Za}=bt;function Ya(e){const{key:t,persistence_UNSTABLE:n}=e,o=Za(e.retainedBy_UNSTABLE);let r,u=0,c=i(e.default)?Oa(e.default.then((e=>(c=Ia(e),e))).catch((e=>{throw c=Da(e),e}))):Ia(e.default);d(e.default);const l=new Map;function d(e){return e}function f(e,n){var o,a;return null!==(o=null!==(a=n.atomValues.get(t))&&void 0!==a?a:r)&&void 0!==o?o:c}const h=ja({key:t,nodeType:"atom",peek:f,get:function(e,o){if(o.atomValues.has(t))return s(o.atomValues.get(t));if(o.nonvalidatedAtoms.has(t)){if(null!=r)return r;if(null==n)return I(`Tried to restore a persisted value for atom ${t} but it has no persistence settings.`),c;const e=o.nonvalidatedAtoms.get(t),a=n.validator(e,Pa),i=a instanceof za?c:Ia(a);return r=i,r}return c},set:function(e,n,o){if(n.atomValues.has(t)){const e=s(n.atomValues.get(t));if("hasValue"===e.state&&o===e.contents)return new Map}else if(!n.nonvalidatedAtoms.has(t)&&o instanceof za)return new Map;return r=void 0,(new Map).set(t,Ia(o))},init:function(n,o,r){var s;if(u++,n.getState().knownAtoms.add(t),"loading"===c.state){const e=()=>{var e;(null!==(e=n.getState().nextTree)&&void 0!==e?e:n.getState().currentTree).atomValues.has(t)||Ha(n,h)};c.contents.finally(e)}const d=null!==(s=e.effects)&&void 0!==s?s:e.effects_UNSTABLE;if(null!=d){let e=!0,s=Pa,u=!1,m=null;function _(r){if(e&&r.key===t){const e=s;return e instanceof za?f(n,o):i(e)?Oa(e.then((e=>e instanceof za?c.toPromise():e))):Ia(e)}return Ga(n,r)}function g(e){return _(e).toPromise()}function S(o){var r;const a=xa(n,null!==(r=n.getState().nextTree)&&void 0!==r?r:n.getState().currentTree,o.key);return!e||o.key!==t||s instanceof za?a:{...a,isSet:!0,loadable:_(o)}}const b=t=>o=>{if(e){const e=_(h),n="hasValue"===e.state?e.contents:Pa;s="function"===typeof o?o(n):o,i(s)&&(s=s.then((e=>(m={effect:t,value:e},e))))}else{if(i(o))throw a("Setting atoms to async values is not implemented.");"function"!==typeof o&&(m={effect:t,value:o}),qa(n,h,"function"===typeof o?e=>{const n=o(e);return m={effect:t,value:n},n}:o)}},T=e=>()=>b(e)(Pa),w=e=>o=>{var r;const{release:a}=n.subscribeToTransactions((n=>{var r;let{currentTree:a,previousTree:i}=n.getState();i||(j("Transaction subscribers notified without a next tree being present -- this is a bug in Recoil"),i=a);const s=null!==(r=a.atomValues.get(t))&&void 0!==r?r:c;if("hasValue"===s.state){var u,l,d,f;const n=s.contents,r=null!==(u=i.atomValues.get(t))&&void 0!==u?u:c,h="hasValue"===r.state?r.contents:Pa;(null===(l=m)||void 0===l?void 0:l.effect)!==e||(null===(d=m)||void 0===d?void 0:d.value)!==n?o(n,h,!a.atomValues.has(t)):(null===(f=m)||void 0===f?void 0:f.effect)===e&&(m=null)}}),t);l.set(n,[...null!==(r=l.get(n))&&void 0!==r?r:[],a])};for(const t of d)try{const e=t({node:h,storeID:n.storeID,trigger:r,setSelf:b(t),resetSelf:T(t),onSet:w(t),getPromise:g,getLoadable:_,getInfo_UNSTABLE:S});var p;if(null!=e)l.set(n,[...null!==(p=l.get(n))&&void 0!==p?p:[],e])}catch(y){s=y,u=!0}if(e=!1,!(s instanceof za)){var v;const e=s,r=u?Da(s):i(e)?Oa(function(e,n){const o=n.then((n=>{var r,a;return(null===(a=(null!==(r=e.getState().nextTree)&&void 0!==r?r:e.getState().currentTree).atomValues.get(t))||void 0===a?void 0:a.contents)===o&&qa(e,h,n),n})).catch((n=>{var r,a;throw(null===(a=(null!==(r=e.getState().nextTree)&&void 0!==r?r:e.getState().currentTree).atomValues.get(t))||void 0===a?void 0:a.contents)===o&&Ka(e,h,Da(n)),n}));return o}(n,e)):Ia(e);o.atomValues.set(t,r),null===(v=n.getState().nextTree)||void 0===v||v.atomValues.set(t,r)}}return()=>{var e;u--,null===(e=l.get(n))||void 0===e||e.forEach((e=>e())),l.delete(n)}},invalidate:function(){r=void 0},shouldDeleteConfigOnRelease:function(){return void 0!==Fa(t)&&u<=0},dangerouslyAllowMutability:e.dangerouslyAllowMutability,persistence_UNSTABLE:e.persistence_UNSTABLE?{type:e.persistence_UNSTABLE.type,backButton:e.persistence_UNSTABLE.backButton}:void 0,shouldRestoreFromSnapshots:!0,retainedBy:o});return h}function Ja(e){const{default:t,...n}=e;return $a(t)?function(e){const t=Ja({...e,default:Pa,persistence_UNSTABLE:void 0===e.persistence_UNSTABLE?void 0:{...e.persistence_UNSTABLE,validator:t=>t instanceof za?t:s(e.persistence_UNSTABLE).validator(t,Pa)},effects:e.effects,effects_UNSTABLE:e.effects_UNSTABLE}),n=Ba({key:`${e.key}__withFallback`,get:({get:n})=>{const o=n(t);return o instanceof za?e.default:o},set:({set:e},n)=>e(t,n),dangerouslyAllowMutability:e.dangerouslyAllowMutability});return Wa(n.key,Fa(e.key)),n}({...n,default:t}):Ya({...n,default:t})}var Xa=Ja;var Qa=class{constructor(e){var t;u(this,"_map",void 0),u(this,"_keyMapper",void 0),this._map=new Map,this._keyMapper=null!==(t=null===e||void 0===e?void 0:e.mapKey)&&void 0!==t?t:e=>e}size(){return this._map.size}has(e){return this._map.has(this._keyMapper(e))}get(e){return this._map.get(this._keyMapper(e))}set(e,t){this._map.set(this._keyMapper(e),t)}delete(e){this._map.delete(this._keyMapper(e))}clear(){this._map.clear()}},ei=Object.freeze({__proto__:null,MapCache:Qa});const{LRUCache:ti}=ea,{MapCache:ni}=ei,oi={equality:"reference",eviction:"none",maxSize:1/0};var ri=function({equality:e=oi.equality,eviction:t=oi.eviction,maxSize:n=oi.maxSize}=oi){return function(e,t,n){switch(e){case"keep-all":return new ni({mapKey:n});case"lru":return new ti({mapKey:n,maxSize:s(t)});case"most-recent":return new ti({mapKey:n,maxSize:1})}throw a(`Unrecognized eviction policy ${e}`)}(t,n,function(e){switch(e){case"reference":return e=>e;case"value":return e=>aa(e)}throw a(`Unrecognized equality policy ${e}`)}(e))};const{setConfigDeletionHandler:ai}=J;var ii=function(e){var t,n;const o=ri({equality:null!==(t=null===(n=e.cachePolicyForParams_UNSTABLE)||void 0===n?void 0:n.equality)&&void 0!==t?t:"value",eviction:"keep-all"});return t=>{var n,r;const a=o.get(t);if(null!=a)return a;const{cachePolicyForParams_UNSTABLE:i,...s}=e,u=Xa({...s,key:`${e.key}__${null!==(n=aa(t))&&void 0!==n?n:"void"}`,default:"function"===typeof e.default?e.default(t):e.default,retainedBy_UNSTABLE:"function"===typeof e.retainedBy_UNSTABLE?e.retainedBy_UNSTABLE(t):e.retainedBy_UNSTABLE,effects:"function"===typeof e.effects?e.effects(t):"function"===typeof e.effects_UNSTABLE?e.effects_UNSTABLE(t):null!==(r=e.effects)&&void 0!==r?r:e.effects_UNSTABLE});return o.set(t,u),ai(u.key,(()=>{o.delete(t)})),u}};const{setConfigDeletionHandler:si}=J;let ui=0;var ci=function(e){var t,n;const o=ri({equality:null!==(t=null===(n=e.cachePolicyForParams_UNSTABLE)||void 0===n?void 0:n.equality)&&void 0!==t?t:"value",eviction:"keep-all"});return t=>{var n;const r=o.get(t);if(null!=r)return r;const a=`${e.key}__selectorFamily/${null!==(n=aa(t,{allowFunctions:!0}))&&void 0!==n?n:"void"}/${ui++}`,i=n=>e.get(t)(n),s=e.cachePolicy_UNSTABLE,u="function"===typeof e.retainedBy_UNSTABLE?e.retainedBy_UNSTABLE(t):e.retainedBy_UNSTABLE;let c;if(null!=e.set){const n=e.set;c=Ba({key:a,get:i,set:(e,o)=>n(t)(e,o),cachePolicy_UNSTABLE:s,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:u})}else c=Ba({key:a,get:i,cachePolicy_UNSTABLE:s,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:u});return o.set(t,c),si(c.key,(()=>{o.delete(t)})),c}};const li=ci({key:"__constant",get:e=>()=>e,cachePolicyForParams_UNSTABLE:{equality:"reference"}});var di=function(e){return li(e)};const fi=ci({key:"__error",get:e=>()=>{throw a(e)},cachePolicyForParams_UNSTABLE:{equality:"reference"}});var hi=function(e){return fi(e)};var pi=function(e){return e};const{loadableWithError:vi,loadableWithPromise:yi,loadableWithValue:mi}=N;function _i(e,t){const n=Array(t.length).fill(void 0),o=Array(t.length).fill(void 0);for(const[a,i]of t.entries())try{n[a]=e(i)}catch(r){o[a]=r}return[n,o]}function gi(e){return null!=e&&!i(e)}function Si(e){return Array.isArray(e)?e:Object.getOwnPropertyNames(e).map((t=>e[t]))}function bi(e,t){return Array.isArray(e)?t:Object.getOwnPropertyNames(e).reduce(((e,n,o)=>({...e,[n]:t[o]})),{})}function Ti(e,t,n){return bi(e,n.map(((e,n)=>null==e?mi(t[n]):i(e)?yi(e):vi(e))))}var wi={waitForNone:ci({key:"__waitForNone",get:e=>({get:t})=>{const n=Si(e),[o,r]=_i(t,n);return Ti(e,o,r)},dangerouslyAllowMutability:!0}),waitForAny:ci({key:"__waitForAny",get:e=>({get:t})=>{const n=Si(e),[o,r]=_i(t,n);return r.some((e=>!i(e)))?Ti(e,o,r):new Promise((t=>{for(const[n,a]of r.entries())i(a)&&a.then((a=>{o[n]=a,r[n]=void 0,t(Ti(e,o,r))})).catch((a=>{r[n]=a,t(Ti(e,o,r))}))}))},dangerouslyAllowMutability:!0}),waitForAll:ci({key:"__waitForAll",get:e=>({get:t})=>{const n=Si(e),[o,r]=_i(t,n);if(r.every((e=>null==e)))return bi(e,o);const a=r.find(gi);if(null!=a)throw a;return Promise.all(r).then((t=>{return bi(e,(n=o,t.map(((e,t)=>void 0===e?n[t]:e))));var n}))},dangerouslyAllowMutability:!0}),waitForAllSettled:ci({key:"__waitForAllSettled",get:e=>({get:t})=>{const n=Si(e),[o,r]=_i(t,n);return r.every((e=>!i(e)))?Ti(e,o,r):Promise.all(r.map(((e,t)=>i(e)?e.then((e=>{o[t]=e,r[t]=void 0})).catch((e=>{o[t]=void 0,r[t]=e})):null))).then((()=>Ti(e,o,r)))},dangerouslyAllowMutability:!0}),noWait:ci({key:"__noWait",get:e=>({get:t})=>{try{return mi(t(e))}catch(n){return i(n)?yi(n):vi(n)}},dangerouslyAllowMutability:!0})};const{RecoilLoadable:Ri}=N,{DefaultValue:Ai}=J,{RecoilRoot:Ei,useRecoilStoreID:Ni}=$n,{isRecoilValue:ki}=O,{retentionZone:Vi}=Se,{freshSnapshot:Li}=sn,{useRecoilState:Mi,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:Ci,useRecoilStateLoadable:Ui,useRecoilValue:Bi,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:Di,useRecoilValueLoadable:Oi,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:Ii,useResetRecoilState:xi,useSetRecoilState:Pi}=Do,{useGotoRecoilSnapshot:zi,useRecoilSnapshot:Fi,useRecoilTransactionObserver:ji}=nr,{useRecoilCallback:Wi}=Ir,{noWait:$i,waitForAll:Gi,waitForAllSettled:Hi,waitForAny:qi,waitForNone:Ki}=wi;var Zi={DefaultValue:Ai,isRecoilValue:ki,RecoilLoadable:Ri,RecoilRoot:Ei,useRecoilStoreID:Ni,useRecoilBridgeAcrossReactRoots_UNSTABLE:lr,atom:Xa,selector:Ba,atomFamily:ii,selectorFamily:ci,constSelector:di,errorSelector:hi,readOnlySelector:pi,noWait:$i,waitForNone:Ki,waitForAny:qi,waitForAll:Gi,waitForAllSettled:Hi,useRecoilValue:Bi,useRecoilValueLoadable:Oi,useRecoilState:Mi,useRecoilStateLoadable:Ui,useSetRecoilState:Pi,useResetRecoilState:xi,useGetRecoilValueInfo_UNSTABLE:ar,useRecoilRefresher_UNSTABLE:Fr,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:Ii,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:Di,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:Ci,useRecoilCallback:Wi,useRecoilTransaction_UNSTABLE:Gr,useGotoRecoilSnapshot:zi,useRecoilSnapshot:Fi,useRecoilTransactionObserver_UNSTABLE:ji,snapshot_UNSTABLE:Li,useRetain:no,retentionZone:Vi},Yi=Zi.RecoilRoot,Ji=Zi.atom,Xi=Zi.useRecoilValue,Qi=Zi.useRecoilState}},function(e){var t=function(t){return e(e.s=t)};e.O(0,[774,179],(function(){return t(1780),t(387)}));var n=e.O();_N_E=n}]);